

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scipy.linalg._basic &mdash; EarthDaily Python Client 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=03e43079" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=4ae1632d" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            EarthDaily Python Client
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">EarthDaily Python Client Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_autosummary/earthdaily.html">earthdaily</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">EarthDaily Python Client</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scipy.linalg._basic</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scipy.linalg._basic</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Author: Pearu Peterson, March 2002</span>
<span class="c1">#</span>
<span class="c1"># w/ additions by Travis Oliphant, March 2002</span>
<span class="c1">#              and Jake Vanderplas, August 2012</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">warnings</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">atleast_1d</span><span class="p">,</span> <span class="n">atleast_2d</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lapack</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_lapack_funcs</span><span class="p">,</span> <span class="n">_compute_lwork</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">LinAlgError</span><span class="p">,</span> <span class="n">_datacopied</span><span class="p">,</span> <span class="n">LinAlgWarning</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._decomp</span><span class="w"> </span><span class="kn">import</span> <span class="n">_asarray_validated</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_decomp</span><span class="p">,</span> <span class="n">_decomp_svd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._solve_toeplitz</span><span class="w"> </span><span class="kn">import</span> <span class="n">levinson</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._cythonized_array_utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">find_det_from_lu</span><span class="p">,</span> <span class="n">bandwidth</span><span class="p">,</span> <span class="n">issymmetric</span><span class="p">,</span>
                                      <span class="n">ishermitian</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;solve&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_triangular&#39;</span><span class="p">,</span> <span class="s1">&#39;solveh_banded&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_banded&#39;</span><span class="p">,</span>
           <span class="s1">&#39;solve_toeplitz&#39;</span><span class="p">,</span> <span class="s1">&#39;solve_circulant&#39;</span><span class="p">,</span> <span class="s1">&#39;inv&#39;</span><span class="p">,</span> <span class="s1">&#39;det&#39;</span><span class="p">,</span> <span class="s1">&#39;lstsq&#39;</span><span class="p">,</span>
           <span class="s1">&#39;pinv&#39;</span><span class="p">,</span> <span class="s1">&#39;pinvh&#39;</span><span class="p">,</span> <span class="s1">&#39;matrix_balance&#39;</span><span class="p">,</span> <span class="s1">&#39;matmul_toeplitz&#39;</span><span class="p">]</span>


<span class="c1"># The numpy facilities for type-casting checks are too slow for small sized</span>
<span class="c1"># arrays and eat away the time budget for the checkups. Here we set a</span>
<span class="c1"># precomputed dict container of the numpy.can_cast() table.</span>

<span class="c1"># It can be used to determine quickly what a dtype can be cast to LAPACK</span>
<span class="c1"># compatible types, i.e., &#39;float32, float64, complex64, complex128&#39;.</span>
<span class="c1"># Then it can be checked via &quot;casting_dict[arr.dtype.char]&quot;</span>
<span class="n">lapack_cast_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="s1">&#39;fdFD&#39;</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)])</span>
                    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s1">&#39;All&#39;</span><span class="p">]}</span>


<span class="c1"># Linear equations</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">lamch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Check arguments during the different steps of the solution phase &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;LAPACK reported an illegal value in </span><span class="si">{</span><span class="o">-</span><span class="n">info</span><span class="si">}</span><span class="s1">-th argument.&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;Matrix is singular.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">lamch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">lamch</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rcond</span> <span class="o">&lt;</span> <span class="n">E</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Ill-conditioned matrix (rcond=</span><span class="si">{</span><span class="n">rcond</span><span class="si">:</span><span class="s1">.6g</span><span class="si">}</span><span class="s1">): &#39;</span>
             <span class="s1">&#39;result may not be accurate.&#39;</span><span class="p">,</span>
             <span class="n">LinAlgWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_find_matrix_structure</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span> <span class="o">=</span> <span class="n">bandwidth</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n_below</span> <span class="o">==</span> <span class="n">n_above</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;diagonal&#39;</span>
    <span class="k">elif</span> <span class="n">n_above</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;lower triangular&#39;</span>
    <span class="k">elif</span> <span class="n">n_below</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;upper triangular&#39;</span>
    <span class="k">elif</span> <span class="n">n_above</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n_below</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;tridiagonal&#39;</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ishermitian</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;hermitian&#39;</span>
    <span class="k">elif</span> <span class="n">issymmetric</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;symmetric&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;general&#39;</span>

    <span class="k">return</span> <span class="n">kind</span><span class="p">,</span> <span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span>


<span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">assume_a</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">transposed</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the linear equation set ``a @ x == b`` for the unknown ``x``</span>
<span class="sd">    for square `a` matrix.</span>

<span class="sd">    If the data matrix is known to be a particular type then supplying the</span>
<span class="sd">    corresponding string to ``assume_a`` key chooses the dedicated solver.</span>
<span class="sd">    The available options are</span>

<span class="sd">    ===================  ================================</span>
<span class="sd">     diagonal             &#39;diagonal&#39;</span>
<span class="sd">     tridiagonal          &#39;tridiagonal&#39;</span>
<span class="sd">     banded               &#39;banded&#39;</span>
<span class="sd">     upper triangular     &#39;upper triangular&#39;</span>
<span class="sd">     lower triangular     &#39;lower triangular&#39;</span>
<span class="sd">     symmetric            &#39;symmetric&#39; (or &#39;sym&#39;)</span>
<span class="sd">     hermitian            &#39;hermitian&#39; (or &#39;her&#39;)</span>
<span class="sd">     positive definite    &#39;positive definite&#39; (or &#39;pos&#39;)</span>
<span class="sd">     general              &#39;general&#39; (or &#39;gen&#39;)</span>
<span class="sd">    ===================  ================================</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (N, N) array_like</span>
<span class="sd">        Square input data</span>
<span class="sd">    b : (N, NRHS) array_like</span>
<span class="sd">        Input data for the right hand side.</span>
<span class="sd">    lower : bool, default: False</span>
<span class="sd">        Ignored unless ``assume_a`` is one of ``&#39;sym&#39;``, ``&#39;her&#39;``, or ``&#39;pos&#39;``.</span>
<span class="sd">        If True, the calculation uses only the data in the lower triangle of `a`;</span>
<span class="sd">        entries above the diagonal are ignored. If False (default), the</span>
<span class="sd">        calculation uses only the data in the upper triangle of `a`; entries</span>
<span class="sd">        below the diagonal are ignored.</span>
<span class="sd">    overwrite_a : bool, default: False</span>
<span class="sd">        Allow overwriting data in `a` (may enhance performance).</span>
<span class="sd">    overwrite_b : bool, default: False</span>
<span class="sd">        Allow overwriting data in `b` (may enhance performance).</span>
<span class="sd">    check_finite : bool, default: True</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>
<span class="sd">    assume_a : str, optional</span>
<span class="sd">        Valid entries are described above.</span>
<span class="sd">        If omitted or ``None``, checks are performed to identify structure so the</span>
<span class="sd">        appropriate solver can be called.</span>
<span class="sd">    transposed : bool, default: False</span>
<span class="sd">        If True, solve ``a.T @ x == b``. Raises `NotImplementedError`</span>
<span class="sd">        for complex `a`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : (N, NRHS) ndarray</span>
<span class="sd">        The solution array.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If size mismatches detected or input a is not square.</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If the matrix is singular.</span>
<span class="sd">    LinAlgWarning</span>
<span class="sd">        If an ill-conditioned input a is detected.</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If transposed is True and input a is a complex matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the input b matrix is a 1-D array with N elements, when supplied</span>
<span class="sd">    together with an NxN input a, it is assumed as a valid column vector</span>
<span class="sd">    despite the apparent size mismatch. This is compatible with the</span>
<span class="sd">    numpy.dot() behavior and the returned result is still 1-D array.</span>

<span class="sd">    The general, symmetric, Hermitian and positive definite solutions are</span>
<span class="sd">    obtained via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of</span>
<span class="sd">    LAPACK respectively.</span>

<span class="sd">    The datatype of the arrays define which solver is called regardless</span>
<span class="sd">    of the values. In other words, even when the complex array entries have</span>
<span class="sd">    precisely zero imaginary parts, the complex solver will be called based</span>
<span class="sd">    on the data type of the array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Given `a` and `b`, solve for `x`:</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[3, 2, 0], [1, -1, 0], [0, 5, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([2, 4, -1])</span>
<span class="sd">    &gt;&gt;&gt; from scipy import linalg</span>
<span class="sd">    &gt;&gt;&gt; x = linalg.solve(a, b)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 2., -2.,  9.])</span>
<span class="sd">    &gt;&gt;&gt; np.dot(a, x) == b</span>
<span class="sd">    array([ True,  True,  True], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Flags for 1-D or N-D right-hand side</span>
    <span class="n">b_is_1D</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># check finite after determining structure</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">_asarray_validated</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">_asarray_validated</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">_ensure_dtype_cdsz</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">overwrite_a</span> <span class="o">=</span> <span class="n">overwrite_a</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">overwrite_b</span> <span class="o">=</span> <span class="n">overwrite_b</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input a needs to be a square matrix.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="c1"># Last chance to catch 1x1 scalar a and 1-D b arrays</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">b1</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input b has to have same number of rows as &#39;</span>
                             <span class="s1">&#39;input a&#39;</span><span class="p">)</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b1</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># regularize 1-D b arrays to 2D</span>
    <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">b1</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">b_is_1D</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">assume_a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;diagonal&#39;</span><span class="p">,</span> <span class="s1">&#39;tridiagonal&#39;</span><span class="p">,</span> <span class="s1">&#39;banded&#39;</span><span class="p">,</span> <span class="s1">&#39;lower triangular&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;upper triangular&#39;</span><span class="p">,</span> <span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="s1">&#39;hermitian&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;positive definite&#39;</span><span class="p">,</span> <span class="s1">&#39;general&#39;</span><span class="p">,</span> <span class="s1">&#39;sym&#39;</span><span class="p">,</span> <span class="s1">&#39;her&#39;</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="s1">&#39;gen&#39;</span><span class="p">}:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">assume_a</span><span class="si">}</span><span class="s1"> is not a recognized matrix structure&#39;</span><span class="p">)</span>

    <span class="c1"># for a real matrix, describe it as &quot;symmetric&quot;, not &quot;hermitian&quot;</span>
    <span class="c1"># (lapack doesn&#39;t know what to do with real hermitian matrices)</span>
    <span class="k">if</span> <span class="n">assume_a</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;hermitian&#39;</span><span class="p">,</span> <span class="s1">&#39;her&#39;</span><span class="p">}</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">a1</span><span class="p">):</span>
        <span class="n">assume_a</span> <span class="o">=</span> <span class="s1">&#39;symmetric&#39;</span>

    <span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">assume_a</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">assume_a</span><span class="p">,</span> <span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span> <span class="o">=</span> <span class="n">_find_matrix_structure</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

    <span class="c1"># Get the correct lamch function.</span>
    <span class="c1"># The LAMCH functions only exists for S and D</span>
    <span class="c1"># So for complex values we have to convert to real/double.</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s1">&#39;fF&#39;</span><span class="p">:</span>  <span class="c1"># single precision</span>
        <span class="n">lamch</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lamch&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lamch</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lamch&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;d&#39;</span><span class="p">)</span>

    <span class="c1"># Currently we do not have the other forms of the norm calculators</span>
    <span class="c1">#   lansy, lanpo, lanhe.</span>
    <span class="c1"># However, in any case they only reduce computations slightly...</span>
    <span class="k">if</span> <span class="n">assume_a</span> <span class="o">==</span> <span class="s1">&#39;diagonal&#39;</span><span class="p">:</span>
        <span class="n">_matrix_norm</span> <span class="o">=</span> <span class="n">_matrix_norm_diagonal</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="o">==</span> <span class="s1">&#39;tridiagonal&#39;</span><span class="p">:</span>
        <span class="n">_matrix_norm</span> <span class="o">=</span> <span class="n">_matrix_norm_tridiagonal</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;lower triangular&#39;</span><span class="p">,</span> <span class="s1">&#39;upper triangular&#39;</span><span class="p">}:</span>
        <span class="n">_matrix_norm</span> <span class="o">=</span> <span class="n">_matrix_norm_triangular</span><span class="p">(</span><span class="n">assume_a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_matrix_norm</span> <span class="o">=</span> <span class="n">_matrix_norm_general</span>

    <span class="c1"># Since the I-norm and 1-norm are the same for symmetric matrices</span>
    <span class="c1"># we can collect them all in this one call</span>
    <span class="c1"># Note however, that when issuing &#39;gen&#39; and form!=&#39;none&#39;, then</span>
    <span class="c1"># the I-norm should be used</span>
    <span class="k">if</span> <span class="n">transposed</span><span class="p">:</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="s1">&#39;I&#39;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">a1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;scipy.linalg.solve can currently &#39;</span>
                                      <span class="s1">&#39;not solve a^T x = b or a^H x = b &#39;</span>
                                      <span class="s1">&#39;for complex matrices.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>

    <span class="n">anorm</span> <span class="o">=</span> <span class="n">_matrix_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">a1</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">)</span>

    <span class="n">info</span><span class="p">,</span> <span class="n">rcond</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="c1"># Generalized case &#39;gesv&#39;</span>
    <span class="k">if</span> <span class="n">assume_a</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;general&#39;</span><span class="p">,</span> <span class="s1">&#39;gen&#39;</span><span class="p">}:</span>
        <span class="n">gecon</span><span class="p">,</span> <span class="n">getrf</span><span class="p">,</span> <span class="n">getrs</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;gecon&#39;</span><span class="p">,</span> <span class="s1">&#39;getrf&#39;</span><span class="p">,</span> <span class="s1">&#39;getrs&#39;</span><span class="p">),</span>
                                               <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">lu</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">getrf</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">getrs</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span>
                        <span class="n">trans</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">rcond</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">gecon</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">anorm</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
    <span class="c1"># Hermitian case &#39;hesv&#39;</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;hermitian&#39;</span><span class="p">,</span> <span class="s1">&#39;her&#39;</span><span class="p">}:</span>
        <span class="n">hecon</span><span class="p">,</span> <span class="n">hesv</span><span class="p">,</span> <span class="n">hesv_lw</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;hecon&#39;</span><span class="p">,</span> <span class="s1">&#39;hesv&#39;</span><span class="p">,</span>
                                                 <span class="s1">&#39;hesv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="n">_compute_lwork</span><span class="p">(</span><span class="n">hesv_lw</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
        <span class="n">lu</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">hesv</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="n">lwork</span><span class="p">,</span>
                                 <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span>
                                 <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">,</span>
                                 <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">rcond</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">hecon</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">anorm</span><span class="p">)</span>
    <span class="c1"># Symmetric case &#39;sysv&#39;</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;symmetric&#39;</span><span class="p">,</span> <span class="s1">&#39;sym&#39;</span><span class="p">}:</span>
        <span class="n">sycon</span><span class="p">,</span> <span class="n">sysv</span><span class="p">,</span> <span class="n">sysv_lw</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;sycon&#39;</span><span class="p">,</span> <span class="s1">&#39;sysv&#39;</span><span class="p">,</span>
                                                 <span class="s1">&#39;sysv_lwork&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="n">_compute_lwork</span><span class="p">(</span><span class="n">sysv_lw</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">lower</span><span class="p">)</span>
        <span class="n">lu</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">sysv</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="n">lwork</span><span class="p">,</span>
                                 <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span>
                                 <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">,</span>
                                 <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">rcond</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">sycon</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">ipvt</span><span class="p">,</span> <span class="n">anorm</span><span class="p">)</span>
    <span class="c1"># Diagonal case</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="o">==</span> <span class="s1">&#39;diagonal&#39;</span><span class="p">:</span>
        <span class="n">diag_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">diag_a</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="n">abs_diag_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">diag_a</span><span class="p">)</span>
        <span class="n">rcond</span> <span class="o">=</span> <span class="n">abs_diag_a</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">/</span> <span class="n">abs_diag_a</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="c1"># Tri-diagonal case</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="o">==</span> <span class="s1">&#39;tridiagonal&#39;</span><span class="p">:</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">transposed</span> <span class="k">else</span> <span class="n">a1</span>
        <span class="n">dl</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">du</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">_gttrf</span><span class="p">,</span> <span class="n">_gttrs</span><span class="p">,</span> <span class="n">_gtcon</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;gttrf&#39;</span><span class="p">,</span> <span class="s1">&#39;gttrs&#39;</span><span class="p">,</span> <span class="s1">&#39;gtcon&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">dl</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">du2</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_gttrf</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">du</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_gttrs</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">du2</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">rcond</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_gtcon</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">du2</span><span class="p">,</span> <span class="n">ipiv</span><span class="p">,</span> <span class="n">anorm</span><span class="p">)</span>
    <span class="c1"># Banded case</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="o">==</span> <span class="s1">&#39;banded&#39;</span><span class="p">:</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span> <span class="o">=</span> <span class="p">((</span><span class="n">a1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">n_above</span><span class="p">,</span> <span class="n">n_below</span><span class="p">)</span> <span class="k">if</span> <span class="n">transposed</span>
                                <span class="k">else</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span><span class="p">))</span>
        <span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span> <span class="o">=</span> <span class="n">bandwidth</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="k">if</span> <span class="n">n_below</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span><span class="p">)</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="n">_to_banded</span><span class="p">(</span><span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
        <span class="n">gbsv</span><span class="p">,</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;gbsv&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="c1"># Next two lines copied from `solve_banded`</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">n_below</span> <span class="o">+</span> <span class="n">n_above</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">gbsv</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">a2</span><span class="p">[</span><span class="n">n_below</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">ab</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">gbsv</span><span class="p">(</span><span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span>
                             <span class="n">overwrite_ab</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="c1"># TODO: wrap gbcon and use to get rcond</span>
    <span class="c1"># Triangular case</span>
    <span class="k">elif</span> <span class="n">assume_a</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;lower triangular&#39;</span><span class="p">,</span> <span class="s1">&#39;upper triangular&#39;</span><span class="p">}:</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="n">assume_a</span> <span class="o">==</span> <span class="s1">&#39;lower triangular&#39;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_solve_triangular</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">,</span>
                                    <span class="n">trans</span><span class="o">=</span><span class="n">transposed</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">_trcon</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;trcon&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">rcond</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">_trcon</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">uplo</span><span class="o">=</span><span class="s1">&#39;L&#39;</span> <span class="k">if</span> <span class="n">lower</span> <span class="k">else</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span>
    <span class="c1"># Positive definite case &#39;posv&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pocon</span><span class="p">,</span> <span class="n">posv</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;pocon&#39;</span><span class="p">,</span> <span class="s1">&#39;posv&#39;</span><span class="p">),</span>
                                       <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">lu</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">posv</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span>
                           <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">,</span>
                           <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
        <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>
        <span class="n">rcond</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">pocon</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">anorm</span><span class="p">)</span>

    <span class="n">_solve_check</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">lamch</span><span class="p">,</span> <span class="n">rcond</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">b_is_1D</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_matrix_norm_diagonal</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">):</span>
    <span class="c1"># Equivalent of dlange for diagonal matrix, assuming</span>
    <span class="c1"># norm is either &#39;I&#39; or &#39;1&#39; (really just not the Frobenius norm)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">if</span> <span class="n">check_finite</span> <span class="k">else</span> <span class="n">d</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_matrix_norm_tridiagonal</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">):</span>
    <span class="c1"># Equivalent of dlange for tridiagonal matrix, assuming</span>
    <span class="c1"># norm is either &#39;I&#39; or &#39;1&#39;</span>
    <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s1">&#39;I&#39;</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># Context to avoid warning before error in cases like -inf + inf</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">d</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">if</span> <span class="n">check_finite</span> <span class="k">else</span> <span class="n">d</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_matrix_norm_triangular</span><span class="p">(</span><span class="n">structure</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fun</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">check_finite</span> <span class="k">else</span> <span class="n">a</span>
        <span class="n">lantr</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lantr&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">lantr</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span> <span class="k">if</span> <span class="n">structure</span> <span class="o">==</span> <span class="s1">&#39;lower triangular&#39;</span> <span class="k">else</span> <span class="s1">&#39;U&#39;</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">fun</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_matrix_norm_general</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">check_finite</span> <span class="k">else</span> <span class="n">a</span>
    <span class="n">lange</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">(</span><span class="s1">&#39;lange&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">lange</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_to_banded</span><span class="p">(</span><span class="n">n_below</span><span class="p">,</span> <span class="n">n_above</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">n_above</span> <span class="o">+</span> <span class="n">n_below</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">ab</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">ab</span><span class="p">[</span><span class="n">n_above</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_above</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">ab</span><span class="p">[</span><span class="n">n_above</span> <span class="o">-</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_below</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">ab</span><span class="p">[</span><span class="n">n_above</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ab</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_dtype_cdsz</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="c1"># Ensure that the dtype of arrays is one of the standard types</span>
    <span class="c1"># compatible with LAPACK functions (single or double precision</span>
    <span class="c1"># real or complex).</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">)</span>
    <span class="nb">complex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span> <span class="k">if</span> <span class="nb">complex</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span> <span class="o">&gt;=</span> <span class="mi">64</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="k">if</span> <span class="nb">complex</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">solve_triangular</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unit_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                     <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the equation ``a x = b`` for `x`, assuming a is a triangular matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M, M) array_like</span>
<span class="sd">        A triangular matrix</span>
<span class="sd">    b : (M,) or (M, N) array_like</span>
<span class="sd">        Right-hand side matrix in ``a x = b``</span>
<span class="sd">    lower : bool, optional</span>
<span class="sd">        Use only data contained in the lower triangle of `a`.</span>
<span class="sd">        Default is to use upper triangle.</span>
<span class="sd">    trans : {0, 1, 2, &#39;N&#39;, &#39;T&#39;, &#39;C&#39;}, optional</span>
<span class="sd">        Type of system to solve:</span>

<span class="sd">        ========  =========</span>
<span class="sd">        trans     system</span>
<span class="sd">        ========  =========</span>
<span class="sd">        0 or &#39;N&#39;  a x  = b</span>
<span class="sd">        1 or &#39;T&#39;  a^T x = b</span>
<span class="sd">        2 or &#39;C&#39;  a^H x = b</span>
<span class="sd">        ========  =========</span>
<span class="sd">    unit_diagonal : bool, optional</span>
<span class="sd">        If True, diagonal elements of `a` are assumed to be 1 and</span>
<span class="sd">        will not be referenced.</span>
<span class="sd">    overwrite_b : bool, optional</span>
<span class="sd">        Allow overwriting data in `b` (may enhance performance)</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : (M,) or (M, N) ndarray</span>
<span class="sd">        Solution to the system ``a x = b``.  Shape of return matches `b`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If `a` is singular</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.9.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Solve the lower triangular system a x = b, where::</span>

<span class="sd">             [3  0  0  0]       [4]</span>
<span class="sd">        a =  [2  1  0  0]   b = [2]</span>
<span class="sd">             [1  0  1  0]       [4]</span>
<span class="sd">             [1  1  1  1]       [2]</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import solve_triangular</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[3, 0, 0, 0], [2, 1, 0, 0], [1, 0, 1, 0], [1, 1, 1, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([4, 2, 4, 2])</span>
<span class="sd">    &gt;&gt;&gt; x = solve_triangular(a, b, lower=True)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 1.33333333, -0.66666667,  2.66666667, -1.33333333])</span>
<span class="sd">    &gt;&gt;&gt; a.dot(x)  # Check the result</span>
<span class="sd">    array([ 4.,  2.,  4.,  2.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected square matrix&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;shapes of a </span><span class="si">{</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> and b </span><span class="si">{</span><span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> are incompatible&#39;</span><span class="p">)</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt_nonempty</span> <span class="o">=</span> <span class="n">solve_triangular</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt_nonempty</span><span class="p">)</span>

    <span class="n">overwrite_b</span> <span class="o">=</span> <span class="n">overwrite_b</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_solve_triangular</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">unit_diagonal</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="c1"># solve_triangular without the input validation</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_solve_triangular</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">trans</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unit_diagonal</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

    <span class="n">trans</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
    <span class="n">trtrs</span><span class="p">,</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;trtrs&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span> <span class="ow">or</span> <span class="n">trans</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">trtrs</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span>
                        <span class="n">trans</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">unitdiag</span><span class="o">=</span><span class="n">unit_diagonal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># transposed system is solved since trtrs expects Fortran ordering</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">trtrs</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="ow">not</span> <span class="n">lower</span><span class="p">,</span>
                        <span class="n">trans</span><span class="o">=</span><span class="ow">not</span> <span class="n">trans</span><span class="p">,</span> <span class="n">unitdiag</span><span class="o">=</span><span class="n">unit_diagonal</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;singular matrix: resolution failed at diagonal </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                          <span class="p">(</span><span class="n">info</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;illegal value in </span><span class="si">%d</span><span class="s1">th argument of internal trtrs&#39;</span> <span class="o">%</span>
                     <span class="p">(</span><span class="o">-</span><span class="n">info</span><span class="p">))</span>


<div class="viewcode-block" id="solve_banded">
<a class="viewcode-back" href="../../../_autosummary/earthdaily.legacy.accessor.whittaker.solve_banded.html#earthdaily.legacy.accessor.whittaker.solve_banded">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">solve_banded</span><span class="p">(</span><span class="n">l_and_u</span><span class="p">,</span> <span class="n">ab</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the equation a x = b for x, assuming a is banded matrix.</span>

<span class="sd">    The matrix a is stored in `ab` using the matrix diagonal ordered form::</span>

<span class="sd">        ab[u + i - j, j] == a[i,j]</span>

<span class="sd">    Example of `ab` (shape of a is (6,6), `u` =1, `l` =2)::</span>

<span class="sd">        *    a01  a12  a23  a34  a45</span>
<span class="sd">        a00  a11  a22  a33  a44  a55</span>
<span class="sd">        a10  a21  a32  a43  a54   *</span>
<span class="sd">        a20  a31  a42  a53   *    *</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    (l, u) : (integer, integer)</span>
<span class="sd">        Number of non-zero lower and upper diagonals</span>
<span class="sd">    ab : (`l` + `u` + 1, M) array_like</span>
<span class="sd">        Banded matrix</span>
<span class="sd">    b : (M,) or (M, K) array_like</span>
<span class="sd">        Right-hand side</span>
<span class="sd">    overwrite_ab : bool, optional</span>
<span class="sd">        Discard data in `ab` (may enhance performance)</span>
<span class="sd">    overwrite_b : bool, optional</span>
<span class="sd">        Discard data in `b` (may enhance performance)</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : (M,) or (M, K) ndarray</span>
<span class="sd">        The solution to the system a x = b. Returned shape depends on the</span>
<span class="sd">        shape of `b`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Solve the banded system a x = b, where::</span>

<span class="sd">            [5  2 -1  0  0]       [0]</span>
<span class="sd">            [1  4  2 -1  0]       [1]</span>
<span class="sd">        a = [0  1  3  2 -1]   b = [2]</span>
<span class="sd">            [0  0  1  2  2]       [2]</span>
<span class="sd">            [0  0  0  1  1]       [3]</span>

<span class="sd">    There is one nonzero diagonal below the main diagonal (l = 1), and</span>
<span class="sd">    two above (u = 2). The diagonal banded form of the matrix is::</span>

<span class="sd">             [*  * -1 -1 -1]</span>
<span class="sd">        ab = [*  2  2  2  2]</span>
<span class="sd">             [5  4  3  2  1]</span>
<span class="sd">             [1  1  1  1  *]</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import solve_banded</span>
<span class="sd">    &gt;&gt;&gt; ab = np.array([[0,  0, -1, -1, -1],</span>
<span class="sd">    ...                [0,  2,  2,  2,  2],</span>
<span class="sd">    ...                [5,  4,  3,  2,  1],</span>
<span class="sd">    ...                [1,  1,  1,  1,  0]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([0, 1, 2, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; x = solve_banded((1, 2), ab, b)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([-2.37288136,  3.93220339, -4.        ,  4.3559322 , -1.3559322 ])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">,</span> <span class="n">as_inexact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">,</span> <span class="n">as_inexact</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Validate shapes.</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shapes of ab and b are not compatible.&quot;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">nlower</span><span class="p">,</span> <span class="n">nupper</span><span class="p">)</span> <span class="o">=</span> <span class="n">l_and_u</span>
    <span class="k">if</span> <span class="n">nlower</span> <span class="o">+</span> <span class="n">nupper</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid values for the number of lower and upper &quot;</span>
                         <span class="s2">&quot;diagonals: l+u+1 (</span><span class="si">%d</span><span class="s2">) does not equal ab.shape[0] &quot;</span>
                         <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nlower</span> <span class="o">+</span> <span class="n">nupper</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ab</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b1</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">overwrite_b</span> <span class="o">=</span> <span class="n">overwrite_b</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">overwrite_b</span><span class="p">))</span>
        <span class="c1"># a1.shape[-1] == 1 -&gt; original matrix is 1x1. Typically, the user</span>
        <span class="c1"># will pass u = l = 0 and `a1` will be 1x1. However, the rest of the</span>
        <span class="c1"># function works with unnecessary rows in `a1` as long as</span>
        <span class="c1"># `a1[u + i - j, j] == a[i,j]`. In the 1x1 case, we want i = j = 0,</span>
        <span class="c1"># so the diagonal is in row `u` of `a1`. See gh-8906.</span>
        <span class="n">b2</span> <span class="o">/=</span> <span class="n">a1</span><span class="p">[</span><span class="n">nupper</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">b2</span>
    <span class="k">if</span> <span class="n">nlower</span> <span class="o">==</span> <span class="n">nupper</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">overwrite_ab</span> <span class="o">=</span> <span class="n">overwrite_ab</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">ab</span><span class="p">)</span>
        <span class="n">gtsv</span><span class="p">,</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;gtsv&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">du</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">dl</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">du2</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">gtsv</span><span class="p">(</span><span class="n">dl</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="p">,</span>
                                   <span class="n">overwrite_ab</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gbsv</span><span class="p">,</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;gbsv&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">nlower</span> <span class="o">+</span> <span class="n">nupper</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">gbsv</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">a2</span><span class="p">[</span><span class="n">nlower</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">a1</span>
        <span class="n">lu</span><span class="p">,</span> <span class="n">piv</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">gbsv</span><span class="p">(</span><span class="n">nlower</span><span class="p">,</span> <span class="n">nupper</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;singular matrix&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;illegal value in </span><span class="si">%d</span><span class="s1">-th argument of internal &#39;</span>
                     <span class="s1">&#39;gbsv/gtsv&#39;</span> <span class="o">%</span> <span class="o">-</span><span class="n">info</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">solveh_banded</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve equation a x = b. a is Hermitian positive-definite banded matrix.</span>

<span class="sd">    Uses Thomas&#39; Algorithm, which is more efficient than standard LU</span>
<span class="sd">    factorization, but should only be used for Hermitian positive-definite</span>
<span class="sd">    matrices.</span>

<span class="sd">    The matrix ``a`` is stored in `ab` either in lower diagonal or upper</span>
<span class="sd">    diagonal ordered form:</span>

<span class="sd">        ab[u + i - j, j] == a[i,j]        (if upper form; i &lt;= j)</span>
<span class="sd">        ab[    i - j, j] == a[i,j]        (if lower form; i &gt;= j)</span>

<span class="sd">    Example of `ab` (shape of ``a`` is (6, 6), number of upper diagonals,</span>
<span class="sd">    ``u`` =2)::</span>

<span class="sd">        upper form:</span>
<span class="sd">        *   *   a02 a13 a24 a35</span>
<span class="sd">        *   a01 a12 a23 a34 a45</span>
<span class="sd">        a00 a11 a22 a33 a44 a55</span>

<span class="sd">        lower form:</span>
<span class="sd">        a00 a11 a22 a33 a44 a55</span>
<span class="sd">        a10 a21 a32 a43 a54 *</span>
<span class="sd">        a20 a31 a42 a53 *   *</span>

<span class="sd">    Cells marked with * are not used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ab : (``u`` + 1, M) array_like</span>
<span class="sd">        Banded matrix</span>
<span class="sd">    b : (M,) or (M, K) array_like</span>
<span class="sd">        Right-hand side</span>
<span class="sd">    overwrite_ab : bool, optional</span>
<span class="sd">        Discard data in `ab` (may enhance performance)</span>
<span class="sd">    overwrite_b : bool, optional</span>
<span class="sd">        Discard data in `b` (may enhance performance)</span>
<span class="sd">    lower : bool, optional</span>
<span class="sd">        Is the matrix in the lower form. (Default is upper form)</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : (M,) or (M, K) ndarray</span>
<span class="sd">        The solution to the system ``a x = b``. Shape of return matches shape</span>
<span class="sd">        of `b`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In the case of a non-positive definite matrix ``a``, the solver</span>
<span class="sd">    `solve_banded` may be used.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Solve the banded system ``A x = b``, where::</span>

<span class="sd">            [ 4  2 -1  0  0  0]       [1]</span>
<span class="sd">            [ 2  5  2 -1  0  0]       [2]</span>
<span class="sd">        A = [-1  2  6  2 -1  0]   b = [2]</span>
<span class="sd">            [ 0 -1  2  7  2 -1]       [3]</span>
<span class="sd">            [ 0  0 -1  2  8  2]       [3]</span>
<span class="sd">            [ 0  0  0 -1  2  9]       [3]</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import solveh_banded</span>

<span class="sd">    ``ab`` contains the main diagonal and the nonzero diagonals below the</span>
<span class="sd">    main diagonal. That is, we use the lower form:</span>

<span class="sd">    &gt;&gt;&gt; ab = np.array([[ 4,  5,  6,  7, 8, 9],</span>
<span class="sd">    ...                [ 2,  2,  2,  2, 2, 0],</span>
<span class="sd">    ...                [-1, -1, -1, -1, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 2, 2, 3, 3, 3])</span>
<span class="sd">    &gt;&gt;&gt; x = solveh_banded(ab, b, lower=True)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 0.03431373,  0.45938375,  0.05602241,  0.47759104,  0.17577031,</span>
<span class="sd">            0.34733894])</span>


<span class="sd">    Solve the Hermitian banded system ``H x = b``, where::</span>

<span class="sd">            [ 8   2-1j   0     0  ]        [ 1  ]</span>
<span class="sd">        H = [2+1j  5     1j    0  ]    b = [1+1j]</span>
<span class="sd">            [ 0   -1j    9   -2-1j]        [1-2j]</span>
<span class="sd">            [ 0    0   -2+1j   6  ]        [ 0  ]</span>

<span class="sd">    In this example, we put the upper diagonals in the array ``hb``:</span>

<span class="sd">    &gt;&gt;&gt; hb = np.array([[0, 2-1j, 1j, -2-1j],</span>
<span class="sd">    ...                [8,  5,    9,   6  ]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 1+1j, 1-2j, 0])</span>
<span class="sd">    &gt;&gt;&gt; x = solveh_banded(hb, b)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 0.07318536-0.02939412j,  0.11877624+0.17696461j,</span>
<span class="sd">            0.10077984-0.23035393j, -0.00479904-0.09358128j])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">ab</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>

    <span class="c1"># Validate shapes.</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shapes of ab and b are not compatible.&quot;</span><span class="p">)</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">b1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b1</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">overwrite_b</span> <span class="o">=</span> <span class="n">overwrite_b</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">overwrite_ab</span> <span class="o">=</span> <span class="n">overwrite_ab</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">ab</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">ptsv</span><span class="p">,</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;ptsv&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">lower</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">real</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">du</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">ptsv</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="p">,</span>
                              <span class="n">overwrite_b</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pbsv</span><span class="p">,</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;pbsv&#39;</span><span class="p">,),</span> <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">pbsv</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> <span class="n">overwrite_ab</span><span class="o">=</span><span class="n">overwrite_ab</span><span class="p">,</span>
                          <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2">th leading minor not positive definite&quot;</span> <span class="o">%</span> <span class="n">info</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;illegal value in </span><span class="si">%d</span><span class="s1">th argument of internal &#39;</span>
                         <span class="s1">&#39;pbsv&#39;</span> <span class="o">%</span> <span class="o">-</span><span class="n">info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">solve_toeplitz</span><span class="p">(</span><span class="n">c_or_cr</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Solve a Toeplitz system using Levinson Recursion</span>

<span class="sd">    The Toeplitz matrix has constant diagonals, with c as its first column</span>
<span class="sd">    and r as its first row. If r is not given, ``r == conjugate(c)`` is</span>
<span class="sd">    assumed.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Beginning in SciPy 1.17, multidimensional input will be treated as a batch,</span>
<span class="sd">        not ``ravel``\ ed. To preserve the existing behavior, ``ravel`` arguments</span>
<span class="sd">        before passing them to `solve_toeplitz`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c_or_cr : array_like or tuple of (array_like, array_like)</span>
<span class="sd">        The vector ``c``, or a tuple of arrays (``c``, ``r``). If not</span>
<span class="sd">        supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is</span>
<span class="sd">        real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row</span>
<span class="sd">        of the Toeplitz matrix is ``[c[0], r[1:]]``.</span>
<span class="sd">    b : (M,) or (M, K) array_like</span>
<span class="sd">        Right-hand side in ``T x = b``.</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (result entirely NaNs) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : (M,) or (M, K) ndarray</span>
<span class="sd">        The solution to the system ``T x = b``. Shape of return matches shape</span>
<span class="sd">        of `b`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    toeplitz : Toeplitz matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The solution is computed using Levinson-Durbin recursion, which is faster</span>
<span class="sd">    than generic least-squares methods, but can be less numerically stable.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Solve the Toeplitz system T x = b, where::</span>

<span class="sd">            [ 1 -1 -2 -3]       [1]</span>
<span class="sd">        T = [ 3  1 -1 -2]   b = [2]</span>
<span class="sd">            [ 6  3  1 -1]       [2]</span>
<span class="sd">            [10  6  3  1]       [5]</span>

<span class="sd">    To specify the Toeplitz matrix, only the first column and the first</span>
<span class="sd">    row are needed.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T</span>
<span class="sd">    &gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 2, 2, 5])</span>

<span class="sd">    &gt;&gt;&gt; from scipy.linalg import solve_toeplitz, toeplitz</span>
<span class="sd">    &gt;&gt;&gt; x = solve_toeplitz((c, r), b)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 1.66666667, -1.        , -2.66666667,  2.33333333])</span>

<span class="sd">    Check the result by creating the full Toeplitz matrix and</span>
<span class="sd">    multiplying it by `x`.  We should get `b`.</span>

<span class="sd">    &gt;&gt;&gt; T = toeplitz(c, r)</span>
<span class="sd">    &gt;&gt;&gt; T.dot(x)</span>
<span class="sd">    array([ 1.,  2.,  2.,  5.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># If numerical stability of this algorithm is a problem, a future</span>
    <span class="c1"># developer might consider implementing other O(N^2) Toeplitz solvers,</span>
    <span class="c1"># such as GKO (https://www.jstor.org/stable/2153371) or Bareiss.</span>

    <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">b_shape</span> <span class="o">=</span> <span class="n">_validate_args_for_toeplitz_ops</span><span class="p">(</span>
        <span class="n">c_or_cr</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">,</span> <span class="n">keep_b_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="c1"># Form a 1-D array of values to be used in the matrix, containing a</span>
    <span class="c1"># reversed copy of r[1:], followed by c.</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;illegal value, `b` is a required argument&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">levinson</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">levinson</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ascontiguousarray</span><span class="p">(</span><span class="n">b</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
                             <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">b_shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_get_axis_len</span><span class="p">(</span><span class="n">aname</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="k">if</span> <span class="n">ax</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span> <span class="o">+=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ax</span> <span class="o">&lt;</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">aname</span><span class="si">}</span><span class="s2">axis&#39; entry is out of bounds&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">solve_circulant</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">singular</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">caxis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">baxis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">outaxis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve C x = b for x, where C is a circulant matrix.</span>

<span class="sd">    `C` is the circulant matrix associated with the vector `c`.</span>

<span class="sd">    The system is solved by doing division in Fourier space. The</span>
<span class="sd">    calculation is::</span>

<span class="sd">        x = ifft(fft(b) / fft(c))</span>

<span class="sd">    where `fft` and `ifft` are the fast Fourier transform and its inverse,</span>
<span class="sd">    respectively. For a large vector `c`, this is *much* faster than</span>
<span class="sd">    solving the system with the full circulant matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c : array_like</span>
<span class="sd">        The coefficients of the circulant matrix.</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Right-hand side matrix in ``a x = b``.</span>
<span class="sd">    singular : str, optional</span>
<span class="sd">        This argument controls how a near singular circulant matrix is</span>
<span class="sd">        handled.  If `singular` is &quot;raise&quot; and the circulant matrix is</span>
<span class="sd">        near singular, a `LinAlgError` is raised. If `singular` is</span>
<span class="sd">        &quot;lstsq&quot;, the least squares solution is returned. Default is &quot;raise&quot;.</span>
<span class="sd">    tol : float, optional</span>
<span class="sd">        If any eigenvalue of the circulant matrix has an absolute value</span>
<span class="sd">        that is less than or equal to `tol`, the matrix is considered to be</span>
<span class="sd">        near singular. If not given, `tol` is set to::</span>

<span class="sd">            tol = abs_eigs.max() * abs_eigs.size * np.finfo(np.float64).eps</span>

<span class="sd">        where `abs_eigs` is the array of absolute values of the eigenvalues</span>
<span class="sd">        of the circulant matrix.</span>
<span class="sd">    caxis : int</span>
<span class="sd">        When `c` has dimension greater than 1, it is viewed as a collection</span>
<span class="sd">        of circulant vectors. In this case, `caxis` is the axis of `c` that</span>
<span class="sd">        holds the vectors of circulant coefficients.</span>
<span class="sd">    baxis : int</span>
<span class="sd">        When `b` has dimension greater than 1, it is viewed as a collection</span>
<span class="sd">        of vectors. In this case, `baxis` is the axis of `b` that holds the</span>
<span class="sd">        right-hand side vectors.</span>
<span class="sd">    outaxis : int</span>
<span class="sd">        When `c` or `b` are multidimensional, the value returned by</span>
<span class="sd">        `solve_circulant` is multidimensional. In this case, `outaxis` is</span>
<span class="sd">        the axis of the result that holds the solution vectors.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Solution to the system ``C x = b``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If the circulant matrix associated with `c` is near singular.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    circulant : circulant matrix</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For a 1-D vector `c` with length `m`, and an array `b`</span>
<span class="sd">    with shape ``(m, ...)``,</span>

<span class="sd">        solve_circulant(c, b)</span>

<span class="sd">    returns the same result as</span>

<span class="sd">        solve(circulant(c), b)</span>

<span class="sd">    where `solve` and `circulant` are from `scipy.linalg`.</span>

<span class="sd">    .. versionadded:: 0.16.0</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import solve_circulant, solve, circulant, lstsq</span>

<span class="sd">    &gt;&gt;&gt; c = np.array([2, 2, 4])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; solve_circulant(c, b)</span>
<span class="sd">    array([ 0.75, -0.25,  0.25])</span>

<span class="sd">    Compare that result to solving the system with `scipy.linalg.solve`:</span>

<span class="sd">    &gt;&gt;&gt; solve(circulant(c), b)</span>
<span class="sd">    array([ 0.75, -0.25,  0.25])</span>

<span class="sd">    A singular example:</span>

<span class="sd">    &gt;&gt;&gt; c = np.array([1, 1, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 2, 3, 4])</span>

<span class="sd">    Calling ``solve_circulant(c, b)`` will raise a `LinAlgError`.  For the</span>
<span class="sd">    least square solution, use the option ``singular=&#39;lstsq&#39;``:</span>

<span class="sd">    &gt;&gt;&gt; solve_circulant(c, b, singular=&#39;lstsq&#39;)</span>
<span class="sd">    array([ 0.25,  1.25,  2.25,  1.25])</span>

<span class="sd">    Compare to `scipy.linalg.lstsq`:</span>

<span class="sd">    &gt;&gt;&gt; x, resid, rnk, s = lstsq(circulant(c), b)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 0.25,  1.25,  2.25,  1.25])</span>

<span class="sd">    A broadcasting example:</span>

<span class="sd">    Suppose we have the vectors of two circulant matrices stored in an array</span>
<span class="sd">    with shape (2, 5), and three `b` vectors stored in an array with shape</span>
<span class="sd">    (3, 5).  For example,</span>

<span class="sd">    &gt;&gt;&gt; c = np.array([[1.5, 2, 3, 0, 0], [1, 1, 4, 3, 2]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.arange(15).reshape(-1, 5)</span>

<span class="sd">    We want to solve all combinations of circulant matrices and `b` vectors,</span>
<span class="sd">    with the result stored in an array with shape (2, 3, 5). When we</span>
<span class="sd">    disregard the axes of `c` and `b` that hold the vectors of coefficients,</span>
<span class="sd">    the shapes of the collections are (2,) and (3,), respectively, which are</span>
<span class="sd">    not compatible for broadcasting. To have a broadcast result with shape</span>
<span class="sd">    (2, 3), we add a trivial dimension to `c`: ``c[:, np.newaxis, :]`` has</span>
<span class="sd">    shape (2, 1, 5). The last dimension holds the coefficients of the</span>
<span class="sd">    circulant matrices, so when we call `solve_circulant`, we can use the</span>
<span class="sd">    default ``caxis=-1``. The coefficients of the `b` vectors are in the last</span>
<span class="sd">    dimension of the array `b`, so we use ``baxis=-1``. If we use the</span>
<span class="sd">    default `outaxis`, the result will have shape (5, 2, 3), so we&#39;ll use</span>
<span class="sd">    ``outaxis=-1`` to put the solution vectors in the last dimension.</span>

<span class="sd">    &gt;&gt;&gt; x = solve_circulant(c[:, np.newaxis, :], b, baxis=-1, outaxis=-1)</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (2, 3, 5)</span>
<span class="sd">    &gt;&gt;&gt; np.set_printoptions(precision=3)  # For compact output of numbers.</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[[-0.118,  0.22 ,  1.277, -0.142,  0.302],</span>
<span class="sd">            [ 0.651,  0.989,  2.046,  0.627,  1.072],</span>
<span class="sd">            [ 1.42 ,  1.758,  2.816,  1.396,  1.841]],</span>
<span class="sd">           [[ 0.401,  0.304,  0.694, -0.867,  0.377],</span>
<span class="sd">            [ 0.856,  0.758,  1.149, -0.412,  0.831],</span>
<span class="sd">            [ 1.31 ,  1.213,  1.603,  0.042,  1.286]]])</span>

<span class="sd">    Check by solving one pair of `c` and `b` vectors (cf. ``x[1, 1, :]``):</span>

<span class="sd">    &gt;&gt;&gt; solve_circulant(c[1], b[1, :])</span>
<span class="sd">    array([ 0.856,  0.758,  1.149, -0.412,  0.831])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">nc</span> <span class="o">=</span> <span class="n">_get_axis_len</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">caxis</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">nb</span> <span class="o">=</span> <span class="n">_get_axis_len</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">baxis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nc</span> <span class="o">!=</span> <span class="n">nb</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Shapes of c </span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> and b </span><span class="si">{</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> are incompatible&#39;</span><span class="p">)</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">solve_circulant</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                             <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">caxis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">abs_fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># This is the same tolerance as used in np.linalg.matrix_rank.</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">abs_fc</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">nc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="k">if</span> <span class="n">tol</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">():</span>
            <span class="n">tol</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">tol</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>

    <span class="n">near_zeros</span> <span class="o">=</span> <span class="n">abs_fc</span> <span class="o">&lt;=</span> <span class="n">tol</span>
    <span class="n">is_near_singular</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">near_zeros</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_near_singular</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">singular</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;near singular circulant matrix.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Replace the small values with 1 to avoid errors in the</span>
            <span class="c1"># division fb/fc below.</span>
            <span class="n">fc</span><span class="p">[</span><span class="n">near_zeros</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">fb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">baxis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">fb</span> <span class="o">/</span> <span class="n">fc</span>

    <span class="k">if</span> <span class="n">is_near_singular</span><span class="p">:</span>
        <span class="c1"># `near_zeros` is a boolean array, same shape as `c`, that is</span>
        <span class="c1"># True where `fc` is (near) zero. `q` is the broadcasted result</span>
        <span class="c1"># of fb / fc, so to set the values of `q` to 0 where `fc` is near</span>
        <span class="c1"># zero, we use a mask that is the broadcast result of an array</span>
        <span class="c1"># of True values shaped like `b` with `near_zeros`.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">near_zeros</span>
        <span class="n">q</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">real</span>
    <span class="k">if</span> <span class="n">outaxis</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">outaxis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="c1"># matrix inversion</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the inverse of a matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Square matrix to be inverted.</span>
<span class="sd">    overwrite_a : bool, optional</span>
<span class="sd">        Discard data in `a` (may improve performance). Default is False.</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrix contains only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ainv : ndarray</span>
<span class="sd">        Inverse of the matrix `a`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If `a` is singular.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `a` is not square, or not 2D.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import linalg</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; linalg.inv(a)</span>
<span class="sd">    array([[-2. ,  1. ],</span>
<span class="sd">           [ 1.5, -0.5]])</span>
<span class="sd">    &gt;&gt;&gt; np.dot(a, linalg.inv(a))</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 0.,  1.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;expected square matrix&#39;</span><span class="p">)</span>

    <span class="c1"># accommodate empty square matrices</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>

    <span class="n">overwrite_a</span> <span class="o">=</span> <span class="n">overwrite_a</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">getrf</span><span class="p">,</span> <span class="n">getri</span><span class="p">,</span> <span class="n">getri_lwork</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;getrf&#39;</span><span class="p">,</span> <span class="s1">&#39;getri&#39;</span><span class="p">,</span>
                                                  <span class="s1">&#39;getri_lwork&#39;</span><span class="p">),</span>
                                                 <span class="p">(</span><span class="n">a1</span><span class="p">,))</span>
    <span class="n">lu</span><span class="p">,</span> <span class="n">piv</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">getrf</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="n">_compute_lwork</span><span class="p">(</span><span class="n">getri_lwork</span><span class="p">,</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># XXX: the following line fixes curious SEGFAULT when</span>
        <span class="c1"># benchmarking 500x500 matrix inverse. This seems to</span>
        <span class="c1"># be a bug in LAPACK ?getri routine because if lwork is</span>
        <span class="c1"># minimal (when using lwork[0] instead of lwork[1]) then</span>
        <span class="c1"># all tests pass. Further investigation is required if</span>
        <span class="c1"># more such SEGFAULTs occur.</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1.01</span> <span class="o">*</span> <span class="n">lwork</span><span class="p">)</span>
        <span class="n">inv_a</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">getri</span><span class="p">(</span><span class="n">lu</span><span class="p">,</span> <span class="n">piv</span><span class="p">,</span> <span class="n">lwork</span><span class="o">=</span><span class="n">lwork</span><span class="p">,</span> <span class="n">overwrite_lu</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;singular matrix&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;illegal value in </span><span class="si">%d</span><span class="s1">-th argument of internal &#39;</span>
                         <span class="s1">&#39;getrf|getri&#39;</span> <span class="o">%</span> <span class="o">-</span><span class="n">info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inv_a</span>


<span class="c1"># Determinant</span>

<span class="k">def</span><span class="w"> </span><span class="nf">det</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the determinant of a matrix</span>

<span class="sd">    The determinant is a scalar that is a function of the associated square</span>
<span class="sd">    matrix coefficients. The determinant value is zero for singular matrices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        Input array to compute determinants for.</span>
<span class="sd">    overwrite_a : bool, optional</span>
<span class="sd">        Allow overwriting data in a (may enhance performance).</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrix contains only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    det : (...) float or complex</span>
<span class="sd">        Determinant of `a`. For stacked arrays, a scalar is returned for each</span>
<span class="sd">        (m, m) slice in the last two dimensions of the input. For example, an</span>
<span class="sd">        input of shape (p, q, m, m) will produce a result of shape (p, q). If</span>
<span class="sd">        all dimensions are 1 a scalar is returned regardless of ndim.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The determinant is computed by performing an LU factorization of the</span>
<span class="sd">    input with LAPACK routine &#39;getrf&#39;, and then calculating the product of</span>
<span class="sd">    diagonal entries of the U factor.</span>

<span class="sd">    Even if the input array is single precision (float32 or complex64), the</span>
<span class="sd">    result will be returned in double precision (float64 or complex128) to</span>
<span class="sd">    prevent overflows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import linalg</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6], [7,8,9]])  # A singular matrix</span>
<span class="sd">    &gt;&gt;&gt; linalg.det(a)</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([[0,2,3], [4,5,6], [7,8,9]])</span>
<span class="sd">    &gt;&gt;&gt; linalg.det(b)</span>
<span class="sd">    3.0</span>
<span class="sd">    &gt;&gt;&gt; # An array with the shape (3, 2, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; c = np.array([[[[1., 2.], [3., 4.]],</span>
<span class="sd">    ...                [[5., 6.], [7., 8.]]],</span>
<span class="sd">    ...               [[[9., 10.], [11., 12.]],</span>
<span class="sd">    ...                [[13., 14.], [15., 16.]]],</span>
<span class="sd">    ...               [[[17., 18.], [19., 20.]],</span>
<span class="sd">    ...                [[21., 22.], [23., 24.]]]])</span>
<span class="sd">    &gt;&gt;&gt; linalg.det(c)  # The resulting shape is (3, 2)</span>
<span class="sd">    array([[-2., -2.],</span>
<span class="sd">           [-2., -2.],</span>
<span class="sd">           [-2., -2.]])</span>
<span class="sd">    &gt;&gt;&gt; linalg.det(c[0, 0])  # Confirm the (0, 0) slice, [[1, 2], [3, 4]]</span>
<span class="sd">    -2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The goal is to end up with a writable contiguous array to pass to Cython</span>

    <span class="c1"># First we check and make arrays.</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray_chkfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">check_finite</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The input array must be at least two-dimensional.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Last 2 dimensions of the array must be square&#39;</span>
                         <span class="sa">f</span><span class="s1">&#39; but received shape </span><span class="si">{</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="c1"># Also check if dtype is LAPACK compatible</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;fdFD&#39;</span><span class="p">:</span>
        <span class="n">dtype_char</span> <span class="o">=</span> <span class="n">lapack_cast_dict</span><span class="p">[</span><span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dtype_char</span><span class="p">:</span>  <span class="c1"># No casting possible</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The dtype &quot;</span><span class="si">{</span><span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; cannot be cast &#39;</span>
                            <span class="s1">&#39;to float(32, 64) or complex(64, 128).&#39;</span><span class="p">)</span>

        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype_char</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># makes a copy, free to scratch</span>
        <span class="n">overwrite_a</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Empty array has determinant 1 because math.</span>
    <span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="o">*</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dtyp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span> <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;FD&#39;</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span>
        <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dtyp</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtyp</span><span class="p">)</span>

    <span class="c1"># Scalar case</span>
    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="p">[()]</span>
        <span class="c1"># Convert float32 to float64, and complex64 to complex128.</span>
        <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s1">&#39;dD&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">a1</span>
        <span class="k">return</span> <span class="n">a1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;d&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> <span class="k">else</span> <span class="n">a1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)</span>

    <span class="c1"># Then check overwrite permission</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>  <span class="c1"># &quot;a&quot;  still alive through &quot;a1&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite_a</span><span class="p">:</span>
            <span class="c1"># Data belongs to &quot;a&quot; so make a copy</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
        <span class="c1">#  else: Do nothing we&#39;ll use &quot;a&quot; if possible</span>
    <span class="c1"># else:  a1 has its own data thus free to scratch</span>

    <span class="c1"># Then layout checks, might happen that overwrite is allowed but original</span>
    <span class="c1"># array was read-only or non-C-contiguous.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;C_CONTIGUOUS&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">a1</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;WRITEABLE&#39;</span><span class="p">]):</span>
        <span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">det</span> <span class="o">=</span> <span class="n">find_det_from_lu</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
        <span class="c1"># Convert float, complex to NumPy scalars</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">det</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">(</span><span class="n">det</span><span class="p">))</span>

    <span class="c1"># loop over the stacked array, and avoid overflows for single precision</span>
    <span class="c1"># Cf. np.linalg.det(np.diag([1e+38, 1e+38]).astype(np.float32))</span>
    <span class="n">dtype_char</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
    <span class="k">if</span> <span class="n">dtype_char</span> <span class="ow">in</span> <span class="s1">&#39;fF&#39;</span><span class="p">:</span>
        <span class="n">dtype_char</span> <span class="o">=</span> <span class="s1">&#39;d&#39;</span> <span class="k">if</span> <span class="n">dtype_char</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span> <span class="k">else</span> <span class="s1">&#39;D&#39;</span>

    <span class="n">det</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype_char</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]]):</span>
        <span class="n">det</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_det_from_lu</span><span class="p">(</span><span class="n">a1</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">det</span>


<span class="c1"># Linear Least Squares</span>
<span class="k">def</span><span class="w"> </span><span class="nf">lstsq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">cond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_b</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lapack_driver</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute least-squares solution to equation Ax = b.</span>

<span class="sd">    Compute a vector x such that the 2-norm ``|b - A x|`` is minimized.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M, N) array_like</span>
<span class="sd">        Left-hand side array</span>
<span class="sd">    b : (M,) or (M, K) array_like</span>
<span class="sd">        Right hand side array</span>
<span class="sd">    cond : float, optional</span>
<span class="sd">        Cutoff for &#39;small&#39; singular values; used to determine effective</span>
<span class="sd">        rank of a. Singular values smaller than</span>
<span class="sd">        ``cond * largest_singular_value`` are considered zero.</span>
<span class="sd">    overwrite_a : bool, optional</span>
<span class="sd">        Discard data in `a` (may enhance performance). Default is False.</span>
<span class="sd">    overwrite_b : bool, optional</span>
<span class="sd">        Discard data in `b` (may enhance performance). Default is False.</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>
<span class="sd">    lapack_driver : str, optional</span>
<span class="sd">        Which LAPACK driver is used to solve the least-squares problem.</span>
<span class="sd">        Options are ``&#39;gelsd&#39;``, ``&#39;gelsy&#39;``, ``&#39;gelss&#39;``. Default</span>
<span class="sd">        (``&#39;gelsd&#39;``) is a good choice.  However, ``&#39;gelsy&#39;`` can be slightly</span>
<span class="sd">        faster on many problems.  ``&#39;gelss&#39;`` was used historically.  It is</span>
<span class="sd">        generally slow but uses less memory.</span>

<span class="sd">        .. versionadded:: 0.17.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : (N,) or (N, K) ndarray</span>
<span class="sd">        Least-squares solution.</span>
<span class="sd">    residues : (K,) ndarray or float</span>
<span class="sd">        Square of the 2-norm for each column in ``b - a x``, if ``M &gt; N`` and</span>
<span class="sd">        ``rank(A) == n`` (returns a scalar if ``b`` is 1-D). Otherwise a</span>
<span class="sd">        (0,)-shaped array is returned.</span>
<span class="sd">    rank : int</span>
<span class="sd">        Effective rank of `a`.</span>
<span class="sd">    s : (min(M, N),) ndarray or None</span>
<span class="sd">        Singular values of `a`. The condition number of ``a`` is</span>
<span class="sd">        ``s[0] / s[-1]``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If computation does not converge.</span>

<span class="sd">    ValueError</span>
<span class="sd">        When parameters are not compatible.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    scipy.optimize.nnls : linear least squares with non-negativity constraint</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When ``&#39;gelsy&#39;`` is used as a driver, `residues` is set to a (0,)-shaped</span>
<span class="sd">    array and `s` is always ``None``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import lstsq</span>
<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>

<span class="sd">    Suppose we have the following data:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2.5, 3.5, 4, 5, 7, 8.5])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([0.3, 1.1, 1.5, 2.0, 3.2, 6.6, 8.6])</span>

<span class="sd">    We want to fit a quadratic polynomial of the form ``y = a + b*x**2``</span>
<span class="sd">    to this data.  We first form the &quot;design matrix&quot; M, with a constant</span>
<span class="sd">    column of 1s and a column containing ``x**2``:</span>

<span class="sd">    &gt;&gt;&gt; M = x[:, np.newaxis]**[0, 2]</span>
<span class="sd">    &gt;&gt;&gt; M</span>
<span class="sd">    array([[  1.  ,   1.  ],</span>
<span class="sd">           [  1.  ,   6.25],</span>
<span class="sd">           [  1.  ,  12.25],</span>
<span class="sd">           [  1.  ,  16.  ],</span>
<span class="sd">           [  1.  ,  25.  ],</span>
<span class="sd">           [  1.  ,  49.  ],</span>
<span class="sd">           [  1.  ,  72.25]])</span>

<span class="sd">    We want to find the least-squares solution to ``M.dot(p) = y``,</span>
<span class="sd">    where ``p`` is a vector with length 2 that holds the parameters</span>
<span class="sd">    ``a`` and ``b``.</span>

<span class="sd">    &gt;&gt;&gt; p, res, rnk, s = lstsq(M, y)</span>
<span class="sd">    &gt;&gt;&gt; p</span>
<span class="sd">    array([ 0.20925829,  0.12013861])</span>

<span class="sd">    Plot the data and the fitted curve.</span>

<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;, label=&#39;data&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xx = np.linspace(0, 9, 101)</span>
<span class="sd">    &gt;&gt;&gt; yy = p[0] + p[1]*xx**2</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(xx, yy, label=&#39;least squares fit, $y = a + bx^2$&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.xlabel(&#39;x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.ylabel(&#39;y&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend(framealpha=1, shadow=True)</span>
<span class="sd">    &gt;&gt;&gt; plt.grid(alpha=0.25)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="n">b1</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Input array a should be 2D&#39;</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">nrhs</span> <span class="o">=</span> <span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nrhs</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Shape mismatch: a and b should have the same number&#39;</span>
                         <span class="sa">f</span><span class="s1">&#39; of rows (</span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s1"> != </span><span class="si">{</span><span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">).&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Zero-sized problem, confuses LAPACK</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,)</span> <span class="o">+</span> <span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">common_type</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">residues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">residues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">residues</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>

    <span class="n">driver</span> <span class="o">=</span> <span class="n">lapack_driver</span>
    <span class="k">if</span> <span class="n">driver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">driver</span> <span class="o">=</span> <span class="n">lstsq</span><span class="o">.</span><span class="n">default_lapack_driver</span>
    <span class="k">if</span> <span class="n">driver</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;gelsd&#39;</span><span class="p">,</span> <span class="s1">&#39;gelsy&#39;</span><span class="p">,</span> <span class="s1">&#39;gelss&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;LAPACK driver &quot;</span><span class="si">{</span><span class="n">driver</span><span class="si">}</span><span class="s1">&quot; is not found&#39;</span><span class="p">)</span>

    <span class="n">lapack_func</span><span class="p">,</span> <span class="n">lapack_lwork</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="n">driver</span><span class="p">,</span>
                                                 <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">driver</span><span class="si">}</span><span class="s1">_lwork&#39;</span><span class="p">),</span>
                                                 <span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">))</span>
    <span class="n">real_data</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">lapack_func</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="c1"># need to extend b matrix as it will be filled with</span>
        <span class="c1"># a larger solution matrix</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">nrhs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">lapack_func</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">b2</span><span class="p">[:</span><span class="n">m</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">b1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">lapack_func</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">b2</span><span class="p">[:</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">b1</span>
        <span class="n">b1</span> <span class="o">=</span> <span class="n">b2</span>

    <span class="n">overwrite_a</span> <span class="o">=</span> <span class="n">overwrite_a</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">overwrite_b</span> <span class="o">=</span> <span class="n">overwrite_b</span> <span class="ow">or</span> <span class="n">_datacopied</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">cond</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">lapack_func</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>

    <span class="k">if</span> <span class="n">driver</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;gelss&#39;</span><span class="p">,</span> <span class="s1">&#39;gelsd&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;gelss&#39;</span><span class="p">:</span>
            <span class="n">lwork</span> <span class="o">=</span> <span class="n">_compute_lwork</span><span class="p">(</span><span class="n">lapack_lwork</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nrhs</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
            <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">lapack_func</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">lwork</span><span class="p">,</span>
                                                    <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">,</span>
                                                    <span class="n">overwrite_b</span><span class="o">=</span><span class="n">overwrite_b</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;gelsd&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">real_data</span><span class="p">:</span>
                <span class="n">lwork</span><span class="p">,</span> <span class="n">iwork</span> <span class="o">=</span> <span class="n">_compute_lwork</span><span class="p">(</span><span class="n">lapack_lwork</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nrhs</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">lapack_func</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">lwork</span><span class="p">,</span>
                                               <span class="n">iwork</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># complex data</span>
                <span class="n">lwork</span><span class="p">,</span> <span class="n">rwork</span><span class="p">,</span> <span class="n">iwork</span> <span class="o">=</span> <span class="n">_compute_lwork</span><span class="p">(</span><span class="n">lapack_lwork</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span>
                                                     <span class="n">nrhs</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">lapack_func</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">lwork</span><span class="p">,</span> <span class="n">rwork</span><span class="p">,</span> <span class="n">iwork</span><span class="p">,</span>
                                               <span class="n">cond</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;SVD did not converge in Linear Least Squares&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;illegal value in </span><span class="si">%d</span><span class="s1">-th argument of internal </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">info</span><span class="p">,</span> <span class="n">lapack_driver</span><span class="p">))</span>
        <span class="n">resids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">rank</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">resids</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">s</span>

    <span class="k">elif</span> <span class="n">driver</span> <span class="o">==</span> <span class="s1">&#39;gelsy&#39;</span><span class="p">:</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="n">_compute_lwork</span><span class="p">(</span><span class="n">lapack_lwork</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">nrhs</span><span class="p">,</span> <span class="n">cond</span><span class="p">)</span>
        <span class="n">jptv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">a1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">lapack_func</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">jptv</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span>
                                          <span class="n">lwork</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;illegal value in </span><span class="si">%d</span><span class="s2">-th argument of internal &quot;</span>
                             <span class="s2">&quot;gelsy&quot;</span> <span class="o">%</span> <span class="o">-</span><span class="n">info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">rank</span><span class="p">,</span> <span class="kc">None</span>


<span class="n">lstsq</span><span class="o">.</span><span class="n">default_lapack_driver</span> <span class="o">=</span> <span class="s1">&#39;gelsd&#39;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_rank</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the (Moore-Penrose) pseudo-inverse of a matrix.</span>

<span class="sd">    Calculate a generalized inverse of a matrix using its</span>
<span class="sd">    singular-value decomposition ``U @ S @ V`` in the economy mode and picking</span>
<span class="sd">    up only the columns/rows that are associated with significant singular</span>
<span class="sd">    values.</span>

<span class="sd">    If ``s`` is the maximum singular value of ``a``, then the</span>
<span class="sd">    significance cut-off value is determined by ``atol + rtol * s``. Any</span>
<span class="sd">    singular value below this value is assumed insignificant.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M, N) array_like</span>
<span class="sd">        Matrix to be pseudo-inverted.</span>
<span class="sd">    atol : float, optional</span>
<span class="sd">        Absolute threshold term, default value is 0.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    rtol : float, optional</span>
<span class="sd">        Relative threshold term, default value is ``max(M, N) * eps`` where</span>
<span class="sd">        ``eps`` is the machine precision value of the datatype of ``a``.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    return_rank : bool, optional</span>
<span class="sd">        If True, return the effective rank of the matrix.</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrix contains only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B : (N, M) ndarray</span>
<span class="sd">        The pseudo-inverse of matrix `a`.</span>
<span class="sd">    rank : int</span>
<span class="sd">        The effective rank of the matrix. Returned if `return_rank` is True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If SVD computation does not converge.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pinvh : Moore-Penrose pseudoinverse of a hermitian matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If ``A`` is invertible then the Moore-Penrose pseudoinverse is exactly</span>
<span class="sd">    the inverse of ``A`` [1]_. If ``A`` is not invertible then the</span>
<span class="sd">    Moore-Penrose pseudoinverse computes the ``x`` solution to ``Ax = b`` such</span>
<span class="sd">    that ``||Ax - b||`` is minimized [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Penrose, R. (1956). On best approximate solutions of linear matrix</span>
<span class="sd">           equations. Mathematical Proceedings of the Cambridge Philosophical</span>
<span class="sd">           Society, 52(1), 17-19. doi:10.1017/S0305004100030929</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Given an ``m x n`` matrix ``A`` and an ``n x m`` matrix ``B`` the four</span>
<span class="sd">    Moore-Penrose conditions are:</span>

<span class="sd">    1. ``ABA = A`` (``B`` is a generalized inverse of ``A``),</span>
<span class="sd">    2. ``BAB = B`` (``A`` is a generalized inverse of ``B``),</span>
<span class="sd">    3. ``(AB)* = AB`` (``AB`` is hermitian),</span>
<span class="sd">    4. ``(BA)* = BA`` (``BA`` is hermitian) [1]_.</span>

<span class="sd">    Here, ``A*`` denotes the conjugate transpose. The Moore-Penrose</span>
<span class="sd">    pseudoinverse is a unique ``B`` that satisfies all four of these</span>
<span class="sd">    conditions and exists for any ``A``. Note that, unlike the standard</span>
<span class="sd">    matrix inverse, ``A`` does not have to be a square matrix or have</span>
<span class="sd">    linearly independent columns/rows.</span>

<span class="sd">    As an example, we can calculate the Moore-Penrose pseudoinverse of a</span>
<span class="sd">    random non-square matrix and verify it satisfies the four conditions.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import linalg</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; A = rng.standard_normal((9, 6))</span>
<span class="sd">    &gt;&gt;&gt; B = linalg.pinv(A)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(A @ B @ A, A)  # Condition 1</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(B @ A @ B, B)  # Condition 2</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose((A @ B).conj().T, A @ B)  # Condition 3</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose((B @ A).conj().T, B @ A)  # Condition 4</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">_decomp_svd</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">maxS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">initial</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

    <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.</span> <span class="k">if</span> <span class="n">atol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">atol</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">if</span> <span class="p">(</span><span class="n">rtol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">rtol</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">atol</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">rtol</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;atol and rtol values must be positive.&quot;</span><span class="p">)</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">atol</span> <span class="o">+</span> <span class="n">maxS</span> <span class="o">*</span> <span class="n">rtol</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span>

    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="p">:</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">/=</span> <span class="n">s</span><span class="p">[:</span><span class="n">rank</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">@</span> <span class="n">vh</span><span class="p">[:</span><span class="n">rank</span><span class="p">])</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">return_rank</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">rank</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">B</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pinvh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_rank</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
          <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</span>

<span class="sd">    Calculate a generalized inverse of a complex Hermitian/real symmetric</span>
<span class="sd">    matrix using its eigenvalue decomposition and including all eigenvalues</span>
<span class="sd">    with &#39;large&#39; absolute value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (N, N) array_like</span>
<span class="sd">        Real symmetric or complex hermetian matrix to be pseudo-inverted</span>

<span class="sd">    atol : float, optional</span>
<span class="sd">        Absolute threshold term, default value is 0.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    rtol : float, optional</span>
<span class="sd">        Relative threshold term, default value is ``N * eps`` where</span>
<span class="sd">        ``eps`` is the machine precision value of the datatype of ``a``.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>

<span class="sd">    lower : bool, optional</span>
<span class="sd">        Whether the pertinent array data is taken from the lower or upper</span>
<span class="sd">        triangle of `a`. (Default: lower)</span>
<span class="sd">    return_rank : bool, optional</span>
<span class="sd">        If True, return the effective rank of the matrix.</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrix contains only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (crashes, non-termination) if the inputs do contain infinities or NaNs.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B : (N, N) ndarray</span>
<span class="sd">        The pseudo-inverse of matrix `a`.</span>
<span class="sd">    rank : int</span>
<span class="sd">        The effective rank of the matrix.  Returned if `return_rank` is True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If eigenvalue algorithm does not converge.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    pinv : Moore-Penrose pseudoinverse of a matrix.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    For a more detailed example see `pinv`.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy.linalg import pinvh</span>
<span class="sd">    &gt;&gt;&gt; rng = np.random.default_rng()</span>
<span class="sd">    &gt;&gt;&gt; a = rng.standard_normal((9, 6))</span>
<span class="sd">    &gt;&gt;&gt; a = np.dot(a, a.T)</span>
<span class="sd">    &gt;&gt;&gt; B = pinvh(a)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, a @ B @ a)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(B, B @ a @ B)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">_decomp</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">lower</span><span class="o">=</span><span class="n">lower</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;ev&#39;</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">maxS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">initial</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>

    <span class="n">atol</span> <span class="o">=</span> <span class="mf">0.</span> <span class="k">if</span> <span class="n">atol</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">atol</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="k">if</span> <span class="p">(</span><span class="n">rtol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">rtol</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">atol</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">rtol</span> <span class="o">&lt;</span> <span class="mf">0.</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;atol and rtol values must be positive.&quot;</span><span class="p">)</span>

    <span class="n">val</span> <span class="o">=</span> <span class="n">atol</span> <span class="o">+</span> <span class="n">maxS</span> <span class="o">*</span> <span class="n">rtol</span>
    <span class="n">above_cutoff</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">)</span>

    <span class="n">psigma_diag</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">s</span><span class="p">[</span><span class="n">above_cutoff</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:,</span> <span class="n">above_cutoff</span><span class="p">]</span>

    <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span> <span class="o">*</span> <span class="n">psigma_diag</span><span class="p">)</span> <span class="o">@</span> <span class="n">u</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">return_rank</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">psigma_diag</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">B</span>


<span class="k">def</span><span class="w"> </span><span class="nf">matrix_balance</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">permute</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">separate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a diagonal similarity transformation for row/column balancing.</span>

<span class="sd">    The balancing tries to equalize the row and column 1-norms by applying</span>
<span class="sd">    a similarity transformation such that the magnitude variation of the</span>
<span class="sd">    matrix entries is reflected to the scaling matrices.</span>

<span class="sd">    Moreover, if enabled, the matrix is first permuted to isolate the upper</span>
<span class="sd">    triangular parts of the matrix and, again if scaling is also enabled,</span>
<span class="sd">    only the remaining subblocks are subjected to scaling.</span>

<span class="sd">    The balanced matrix satisfies the following equality</span>

<span class="sd">    .. math::</span>

<span class="sd">                        B = T^{-1} A T</span>

<span class="sd">    The scaling coefficients are approximated to the nearest power of 2</span>
<span class="sd">    to avoid round-off errors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : (n, n) array_like</span>
<span class="sd">        Square data matrix for the balancing.</span>
<span class="sd">    permute : bool, optional</span>
<span class="sd">        The selector to define whether permutation of A is also performed</span>
<span class="sd">        prior to scaling.</span>
<span class="sd">    scale : bool, optional</span>
<span class="sd">        The selector to turn on and off the scaling. If False, the matrix</span>
<span class="sd">        will not be scaled.</span>
<span class="sd">    separate : bool, optional</span>
<span class="sd">        This switches from returning a full matrix of the transformation</span>
<span class="sd">        to a tuple of two separate 1-D permutation and scaling arrays.</span>
<span class="sd">    overwrite_a : bool, optional</span>
<span class="sd">        This is passed to xGEBAL directly. Essentially, overwrites the result</span>
<span class="sd">        to the data. It might increase the space efficiency. See LAPACK manual</span>
<span class="sd">        for details. This is False by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B : (n, n) ndarray</span>
<span class="sd">        Balanced matrix</span>
<span class="sd">    T : (n, n) ndarray</span>
<span class="sd">        A possibly permuted diagonal matrix whose nonzero entries are</span>
<span class="sd">        integer powers of 2 to avoid numerical truncation errors.</span>
<span class="sd">    scale, perm : (n,) ndarray</span>
<span class="sd">        If ``separate`` keyword is set to True then instead of the array</span>
<span class="sd">        ``T`` above, the scaling and the permutation vectors are given</span>
<span class="sd">        separately as a tuple without allocating the full array ``T``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This algorithm is particularly useful for eigenvalue and matrix</span>
<span class="sd">    decompositions and in many cases it is already called by various</span>
<span class="sd">    LAPACK routines.</span>

<span class="sd">    The algorithm is based on the well-known technique of [1]_ and has</span>
<span class="sd">    been modified to account for special cases. See [2]_ for details</span>
<span class="sd">    which have been implemented since LAPACK v3.5.0. Before this version</span>
<span class="sd">    there are corner cases where balancing can actually worsen the</span>
<span class="sd">    conditioning. See [3]_ for such examples.</span>

<span class="sd">    The code is a wrapper around LAPACK&#39;s xGEBAL routine family for matrix</span>
<span class="sd">    balancing.</span>

<span class="sd">    .. versionadded:: 0.19.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] B.N. Parlett and C. Reinsch, &quot;Balancing a Matrix for</span>
<span class="sd">       Calculation of Eigenvalues and Eigenvectors&quot;, Numerische Mathematik,</span>
<span class="sd">       Vol.13(4), 1969, :doi:`10.1007/BF02165404`</span>
<span class="sd">    .. [2] R. James, J. Langou, B.R. Lowery, &quot;On matrix balancing and</span>
<span class="sd">       eigenvector computation&quot;, 2014, :arxiv:`1401.5766`</span>
<span class="sd">    .. [3] D.S. Watkins. A case where balancing is harmful.</span>
<span class="sd">       Electron. Trans. Numer. Anal, Vol.23, 2006.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from scipy import linalg</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1,2,0], [9,1,0.01], [1,2,10*np.pi]])</span>

<span class="sd">    &gt;&gt;&gt; y, permscale = linalg.matrix_balance(x)</span>
<span class="sd">    &gt;&gt;&gt; np.abs(x).sum(axis=0) / np.abs(x).sum(axis=1)</span>
<span class="sd">    array([ 3.66666667,  0.4995005 ,  0.91312162])</span>

<span class="sd">    &gt;&gt;&gt; np.abs(y).sum(axis=0) / np.abs(y).sum(axis=1)</span>
<span class="sd">    array([ 1.2       ,  1.27041742,  0.92658316])  # may vary</span>

<span class="sd">    &gt;&gt;&gt; permscale  # only powers of 2 (0.5 == 2^(-1))</span>
<span class="sd">    array([[  0.5,   0. ,  0. ],  # may vary</span>
<span class="sd">           [  0. ,   1. ,  0. ],</span>
<span class="sd">           [  0. ,   0. ,  1. ]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">_asarray_validated</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="o">*</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The data matrix for balancing should be square.&#39;</span><span class="p">)</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">A</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b_n</span><span class="p">,</span> <span class="n">t_n</span> <span class="o">=</span> <span class="n">matrix_balance</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">b_n</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">separate</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
            <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="p">(</span><span class="n">scaling</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">t_n</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">gebal</span> <span class="o">=</span> <span class="n">get_lapack_funcs</span><span class="p">((</span><span class="s1">&#39;gebal&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">A</span><span class="p">,))</span>
    <span class="n">B</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">ps</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">gebal</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">permute</span><span class="o">=</span><span class="n">permute</span><span class="p">,</span>
                                <span class="n">overwrite_a</span><span class="o">=</span><span class="n">overwrite_a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">info</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;xGEBAL exited with the internal error &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;&quot;illegal value in argument number </span><span class="si">{</span><span class="o">-</span><span class="n">info</span><span class="si">}</span><span class="s1">.&quot;. See &#39;</span>
                         <span class="s1">&#39;LAPACK documentation for the xGEBAL error codes.&#39;</span><span class="p">)</span>

    <span class="c1"># Separate the permutations from the scalings and then convert to int</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">ps</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">scaling</span><span class="p">[</span><span class="n">lo</span><span class="p">:</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">lo</span><span class="p">:</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># gebal uses 1-indexing</span>
    <span class="n">ps</span> <span class="o">=</span> <span class="n">ps</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="c1"># LAPACK permutes with the ordering n --&gt; hi, then 0--&gt; lo</span>
    <span class="k">if</span> <span class="n">hi</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">hi</span><span class="o">+</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">n</span><span class="o">-</span><span class="n">ind</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">perm</span><span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="n">ind</span><span class="p">]]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[[</span><span class="n">n</span><span class="o">-</span><span class="n">ind</span><span class="p">,</span> <span class="n">x</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">lo</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ps</span><span class="p">[:</span><span class="n">lo</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">ind</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">perm</span><span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="n">ind</span><span class="p">]]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[[</span><span class="n">ind</span><span class="p">,</span> <span class="n">x</span><span class="p">]]</span>

    <span class="k">if</span> <span class="n">separate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="p">(</span><span class="n">scaling</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>

    <span class="c1"># get the inverse permutation</span>
    <span class="n">iperm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span>
    <span class="n">iperm</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">scaling</span><span class="p">)[</span><span class="n">iperm</span><span class="p">,</span> <span class="p">:]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_validate_args_for_toeplitz_ops</span><span class="p">(</span><span class="n">c_or_cr</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">,</span> <span class="n">keep_b_shape</span><span class="p">,</span>
                                    <span class="n">enforce_square</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate arguments and format inputs for toeplitz functions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c_or_cr : array_like or tuple of (array_like, array_like)</span>
<span class="sd">        The vector ``c``, or a tuple of arrays (``c``, ``r``). Whatever the</span>
<span class="sd">        actual shape of ``c``, it will be converted to a 1-D array. If not</span>
<span class="sd">        supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is</span>
<span class="sd">        real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row</span>
<span class="sd">        of the Toeplitz matrix is ``[c[0], r[1:]]``. Whatever the actual shape</span>
<span class="sd">        of ``r``, it will be converted to a 1-D array.</span>
<span class="sd">    b : (M,) or (M, K) array_like</span>
<span class="sd">        Right-hand side in ``T x = b``.</span>
<span class="sd">    check_finite : bool</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (result entirely NaNs) if the inputs do contain infinities or NaNs.</span>
<span class="sd">    keep_b_shape : bool</span>
<span class="sd">        Whether to convert a (M,) dimensional b into a (M, 1) dimensional</span>
<span class="sd">        matrix.</span>
<span class="sd">    enforce_square : bool, optional</span>
<span class="sd">        If True (default), this verifies that the Toeplitz matrix is square.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r : array</span>
<span class="sd">        1d array corresponding to the first row of the Toeplitz matrix.</span>
<span class="sd">    c: array</span>
<span class="sd">        1d array corresponding to the first column of the Toeplitz matrix.</span>
<span class="sd">    b: array</span>
<span class="sd">        (M,), (M, 1) or (M, K) dimensional array, post validation,</span>
<span class="sd">        corresponding to ``b``.</span>
<span class="sd">    dtype: numpy datatype</span>
<span class="sd">        ``dtype`` stores the datatype of ``r``, ``c`` and ``b``. If any of</span>
<span class="sd">        ``r``, ``c`` or ``b`` are complex, ``dtype`` is ``np.complex128``,</span>
<span class="sd">        otherwise, it is ``np.float``.</span>
<span class="sd">    b_shape: tuple</span>
<span class="sd">        Shape of ``b`` after passing it through ``_asarray_validated``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c_or_cr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">c_or_cr</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">c_or_cr</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">r</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Beginning in SciPy 1.17, multidimensional input will be treated as a &quot;</span>
               <span class="s2">&quot;batch, not `ravel`ed. To preserve the existing behavior and silence &quot;</span>
               <span class="s2">&quot;this warning, `ravel` arguments before passing them to &quot;</span>
               <span class="s2">&quot;`toeplitz`, `matmul_toeplitz`, and `solve_toeplitz`.&quot;</span><span class="p">)</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">FutureWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`b` must be an array, not None.&#39;</span><span class="p">)</span>

    <span class="n">b</span> <span class="o">=</span> <span class="n">_asarray_validated</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="n">check_finite</span><span class="p">)</span>
    <span class="n">b_shape</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">is_not_square</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">enforce_square</span> <span class="ow">and</span> <span class="n">is_not_square</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incompatible dimensions.&#39;</span><span class="p">)</span>

    <span class="n">is_cmplx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="k">if</span> <span class="n">is_cmplx</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keep_b_shape</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">b_shape</span>


<span class="k">def</span><span class="w"> </span><span class="nf">matmul_toeplitz</span><span class="p">(</span><span class="n">c_or_cr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Efficient Toeplitz Matrix-Matrix Multiplication using FFT</span>

<span class="sd">    This function returns the matrix multiplication between a Toeplitz</span>
<span class="sd">    matrix and a dense matrix.</span>

<span class="sd">    The Toeplitz matrix has constant diagonals, with c as its first column</span>
<span class="sd">    and r as its first row. If r is not given, ``r == conjugate(c)`` is</span>
<span class="sd">    assumed.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Beginning in SciPy 1.17, multidimensional input will be treated as a batch,</span>
<span class="sd">        not ``ravel``\ ed. To preserve the existing behavior, ``ravel`` arguments</span>
<span class="sd">        before passing them to `matmul_toeplitz`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    c_or_cr : array_like or tuple of (array_like, array_like)</span>
<span class="sd">        The vector ``c``, or a tuple of arrays (``c``, ``r``). If not</span>
<span class="sd">        supplied, ``r = conjugate(c)`` is assumed; in this case, if c[0] is</span>
<span class="sd">        real, the Toeplitz matrix is Hermitian. r[0] is ignored; the first row</span>
<span class="sd">        of the Toeplitz matrix is ``[c[0], r[1:]]``.</span>
<span class="sd">    x : (M,) or (M, K) array_like</span>
<span class="sd">        Matrix with which to multiply.</span>
<span class="sd">    check_finite : bool, optional</span>
<span class="sd">        Whether to check that the input matrices contain only finite numbers.</span>
<span class="sd">        Disabling may give a performance gain, but may result in problems</span>
<span class="sd">        (result entirely NaNs) if the inputs do contain infinities or NaNs.</span>
<span class="sd">    workers : int, optional</span>
<span class="sd">        To pass to scipy.fft.fft and ifft. Maximum number of workers to use</span>
<span class="sd">        for parallel computation. If negative, the value wraps around from</span>
<span class="sd">        ``os.cpu_count()``. See scipy.fft.fft for more details.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    T @ x : (M,) or (M, K) ndarray</span>
<span class="sd">        The result of the matrix multiplication ``T @ x``. Shape of return</span>
<span class="sd">        matches shape of `x`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    toeplitz : Toeplitz matrix</span>
<span class="sd">    solve_toeplitz : Solve a Toeplitz system using Levinson Recursion</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Toeplitz matrix is embedded in a circulant matrix and the FFT is used</span>
<span class="sd">    to efficiently calculate the matrix-matrix product.</span>

<span class="sd">    Because the computation is based on the FFT, integer inputs will</span>
<span class="sd">    result in floating point outputs.  This is unlike NumPy&#39;s `matmul`,</span>
<span class="sd">    which preserves the data type of the input.</span>

<span class="sd">    This is partly based on the implementation that can be found in [1]_,</span>
<span class="sd">    licensed under the MIT license. More information about the method can be</span>
<span class="sd">    found in reference [2]_. References [3]_ and [4]_ have more reference</span>
<span class="sd">    implementations in Python.</span>

<span class="sd">    .. versionadded:: 1.6.0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Jacob R Gardner, Geoff Pleiss, David Bindel, Kilian</span>
<span class="sd">       Q Weinberger, Andrew Gordon Wilson, &quot;GPyTorch: Blackbox Matrix-Matrix</span>
<span class="sd">       Gaussian Process Inference with GPU Acceleration&quot; with contributions</span>
<span class="sd">       from Max Balandat and Ruihan Wu. Available online:</span>
<span class="sd">       https://github.com/cornellius-gp/gpytorch</span>

<span class="sd">    .. [2] J. Demmel, P. Koev, and X. Li, &quot;A Brief Survey of Direct Linear</span>
<span class="sd">       Solvers&quot;. In Z. Bai, J. Demmel, J. Dongarra, A. Ruhe, and H. van der</span>
<span class="sd">       Vorst, editors. Templates for the Solution of Algebraic Eigenvalue</span>
<span class="sd">       Problems: A Practical Guide. SIAM, Philadelphia, 2000. Available at:</span>
<span class="sd">       http://www.netlib.org/utk/people/JackDongarra/etemplates/node384.html</span>

<span class="sd">    .. [3] R. Scheibler, E. Bezzam, I. Dokmanic, Pyroomacoustics: A Python</span>
<span class="sd">       package for audio room simulations and array processing algorithms,</span>
<span class="sd">       Proc. IEEE ICASSP, Calgary, CA, 2018.</span>
<span class="sd">       https://github.com/LCAV/pyroomacoustics/blob/pypi-release/</span>
<span class="sd">       pyroomacoustics/adaptive/util.py</span>

<span class="sd">    .. [4] Marano S, Edwards B, Ferrari G and Fah D (2017), &quot;Fitting</span>
<span class="sd">       Earthquake Spectra: Colored Noise and Incomplete Data&quot;, Bulletin of</span>
<span class="sd">       the Seismological Society of America., January, 2017. Vol. 107(1),</span>
<span class="sd">       pp. 276-291.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Multiply the Toeplitz matrix T with matrix x::</span>

<span class="sd">            [ 1 -1 -2 -3]       [1 10]</span>
<span class="sd">        T = [ 3  1 -1 -2]   x = [2 11]</span>
<span class="sd">            [ 6  3  1 -1]       [2 11]</span>
<span class="sd">            [10  6  3  1]       [5 19]</span>

<span class="sd">    To specify the Toeplitz matrix, only the first column and the first</span>
<span class="sd">    row are needed.</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; c = np.array([1, 3, 6, 10])    # First column of T</span>
<span class="sd">    &gt;&gt;&gt; r = np.array([1, -1, -2, -3])  # First row of T</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([[1, 10], [2, 11], [2, 11], [5, 19]])</span>

<span class="sd">    &gt;&gt;&gt; from scipy.linalg import toeplitz, matmul_toeplitz</span>
<span class="sd">    &gt;&gt;&gt; matmul_toeplitz((c, r), x)</span>
<span class="sd">    array([[-20., -80.],</span>
<span class="sd">           [ -7.,  -8.],</span>
<span class="sd">           [  9.,  85.],</span>
<span class="sd">           [ 33., 218.]])</span>

<span class="sd">    Check the result by creating the full Toeplitz matrix and</span>
<span class="sd">    multiplying it by ``x``.</span>

<span class="sd">    &gt;&gt;&gt; toeplitz(c, r) @ x</span>
<span class="sd">    array([[-20, -80],</span>
<span class="sd">           [ -7,  -8],</span>
<span class="sd">           [  9,  85],</span>
<span class="sd">           [ 33, 218]])</span>

<span class="sd">    The full matrix is never formed explicitly, so this routine</span>
<span class="sd">    is suitable for very large Toeplitz matrices.</span>

<span class="sd">    &gt;&gt;&gt; n = 1000000</span>
<span class="sd">    &gt;&gt;&gt; matmul_toeplitz([1] + [0]*(n-1), np.ones(n))</span>
<span class="sd">    array([1., 1., 1., ..., 1., 1., 1.], shape=(1000000,))</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">..fft</span><span class="w"> </span><span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span><span class="p">,</span> <span class="n">rfft</span><span class="p">,</span> <span class="n">irfft</span>

    <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">x_shape</span> <span class="o">=</span> <span class="n">_validate_args_for_toeplitz_ops</span><span class="p">(</span>
        <span class="n">c_or_cr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">check_finite</span><span class="p">,</span> <span class="n">keep_b_shape</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">enforce_square</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">T_nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="n">T_ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">T_nrows</span> <span class="o">+</span> <span class="n">T_ncols</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># equivalent to len(embedded_col)</span>
    <span class="n">return_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">T_nrows</span><span class="p">,)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="p">(</span><span class="n">T_nrows</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># accommodate empty arrays</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">return_shape</span><span class="p">)</span>

    <span class="n">embedded_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">embedded_col</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">fft_mat</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">embedded_col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fft_x</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">)</span>

        <span class="n">mat_times_x</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">fft_mat</span><span class="o">*</span><span class="n">fft_x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                           <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">)[:</span><span class="n">T_nrows</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Real inputs; using rfft is faster</span>
        <span class="n">fft_mat</span> <span class="o">=</span> <span class="n">rfft</span><span class="p">(</span><span class="n">embedded_col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fft_x</span> <span class="o">=</span> <span class="n">rfft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">)</span>

        <span class="n">mat_times_x</span> <span class="o">=</span> <span class="n">irfft</span><span class="p">(</span><span class="n">fft_mat</span><span class="o">*</span><span class="n">fft_x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">workers</span><span class="o">=</span><span class="n">workers</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">p</span><span class="p">)[:</span><span class="n">T_nrows</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">mat_times_x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">return_shape</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, EarthDaily.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  
<div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    v: main
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    <dl>
      <dt>Tags</dt>
      <dd><a href="../../../../1.0.0/index.html">1.0.0</a></dd>
      <dd><a href="../../../../v0.5.9/index.html">v0.5.9</a></dd>
    </dl>
    <dl>
      <dt>Branches</dt>
      <dd><a href="_basic.html">main</a></dd>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>